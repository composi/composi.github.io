<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="description" content="Composi is a JavaScript library for creating component-based interfaces. It uses the virtual DOM to make efficient updates to the DOM based on a component's data or state.">
  <meta name="keywords" content="javascript, framework, performance, small, fast, UI, programming, code, component, composi, chocolatechipui, chocolatechip-ui, reactive, virtual dom">
  <title>Composi - Docs</title>
  <link rel="stylesheet" href="/css/styles.css">
  <link rel="stylesheet" href="/css/prism.css">
  <link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32" />
  <link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16" />
</head>
<body class='page'>
  <nav>
    <ul class='nav-menu'>
      <li class='nav-menu__item'>
        <a class='nav-menu__item__link' href="/index.html">
          <svg id='composi-logo' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
            <title>Composi Logo</title>
            <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
              <g id="Composi-Logo-Solid" fill="#fff">
                <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
              </g>
            </g>
          </svg>
        <span class='logo__link--text'>Composi</span></a>
      </li>
      <li class='nav-menu__item selected'>
        <a class='nav-menu__item__link' href="/en/docs/index.html">Docs</a>
      </li>
    </ul>
  </nav>
  <article class='article'>
    <section>
      <div class='docs'>
        <h3>@composi/runtime:</h3>
        <ul class='breadcrumb'>
          <li><a href="/en/docs/runtime/runtime.html">Runtime</a></li>
          <li><a href="/en/docs/runtime/init.html">Init</a></li>
          <li><a href="/en/docs/runtime/view.html">View</a></li>
          <li><a href="/en/docs/runtime/update.html">Update</a></li>
          <li><a href="/en/docs/runtime/effects.html">Effects</a></li>
          <li><a href="/en/docs/runtime/tagged-unions.html">Tagged Unions</a></li>
          <li class='selected'>Subscriptions</li>
          <li><a href="/en/docs/runtime/composition.html">Composition</a></li>
          <li><a href="/en/docs/runtime/end-program.html">Stop Program</a></li>
          <li><a href="/en/docs/runtime/immutability.html">Immutability</a></li>
          <li><a href="/en/docs/runtime/hop.html">Higher Order Program</a></li>
        </ul>
          <h1>Subscriptions</h1>
          <h2>Running Effects at Startup</h2>
          <p>When we covered <code>init</code> it was explained how you could execute an effect at startup by passing it as a second value in the tuple that <code>init</code> returns. Generally effects that run at startup are referred to as subscriptions. You can be more explicit about implementing a subscription by using the <code>subscriptions</code> method on a program.  This needs to return the subscription to execute.</p>
          <p>You would use subscriptions to track mouse movements, keyboard events, scrolling, changes to browser location, or timers.</p>
<pre><code class="language-javascript">function startCount() {
  let count = 0
  const id = setInterval(() => {
    if (count === 10) clearInterval(id)
    count += 1
    program.send(count)
  }, 1000)
}
const program = {
  init() {
    return [state]
  },
  view(state, send) {
    return render(<h1>The count is: {state}.</h1>, document.body)
  },
  update(state, msg) {
    if (msg) {
      // Set program state to value of message:
      return [msg]
    }
  },
  subsciptions(state, send) {
    return startCount
  }
}</code></pre>
          <p>There is no magic here. Subscriptions does what the label says. Using subscriptions to run effects at start is more explicit. But you can use whatever approach, init or subscriptions, to run effects at startup. Subscriptions gets state and send passed to it. This means you can access the program's state and send a message to an update action.</p>
          <p>Regardless of whether you use state and send in your subscriptions, the program method requires them as parameters:</p>
<pre><code class="language-javascript">const program = {
  init() {

  },
  view(state, send) {

  },
  update(state, msg) {

  },
  // state and send required as arguments here:
  subscriptions(state, send) {

  }
}
</code></pre>
          <p><strong>Note:</strong> Subscriptions are not for manipulating state. Changing state in an subscription will result in the view and state being out of sync. If you have produced some data in an effect and want to update state, do so by sending a message to an action. Doing so will trigger the reconciliation algorythm and a possible re-render of the view.</p>

          <h2>Batched Subscriptions</h2>

          <p>Like any other effects, you can use <code>batchEffects</code> to run multiple effects at the same time. See the documentation for <a href="/en/docs/runtime/effects.html">effects</a> to learn how to use  <code>batcheEffects</code>.</p>

          <p>Now let's look at how to use batched subscriptions. We are going to take two effects, one to fetch data and one to set up an event to listen for key presses that we want to execute when our program starts. Since there are two effects, rather than putting them directly in the body of the <code>subscriptions</code> program method, we'll keep them separate and use a batched version. Since we're fetching data at start up, there will be no state for the initial vew render. In our view we'll check whether state is truthy or not before returning the rendered view. And in our initial setup for state in the <code>init</code> method we will set state to null.</p>
<pre><code class='language-javascript'>// Below are two effects.
// Each effect expects the `send` function as its argument.
// This will get passed automatically when the batched effects are processed.

// Subscription effect to fetch data:
function fetchState(send) {
  fetch('/src/js/state.json')
    .then(function (response) {
      return response.json();
    })
    .then(data => {
      send(Msg.fetchThenRender(data))
    })
}
// Subscription effect to handle Enter key:
function handleEnter(send) {
  document.addEventListener('keypress', function (e) {
    if (e.keyCode === 13) {
      send(Msg.addItem())
    }
  })
}

// Batch subscrption effects together:
const batchedSubscriptions = batchEffects([fetchState, handleEnter])

// Define program to run:
const program = {
  init() {
    // Here we set state to null:
    return [null]
  },
  view(state, send) {
    // Here we check if state is truthy or not:
    return state && render(<List {...{ state, send }}/>, 'section')
  },
  update(state, msg) {
    const prevState = mergeObjects(state)
    return actions(prevState, msg)
  },
  subscriptions(state, send) {
    // Here we return the batched effects.
    // Notice that we do not need to call them, just return them.
    return batchedSubscriptions
  }
}</code></pre>
          <p> </p>
          <h3>Shortcut</h3>
          <p>Instead of using <code>subscriptions</code> you can use the shorter form <code>subs</code>:</p>

<pre><code class="language-javascript">
const program = {
  init() {
    return [state]
  },
  view(state, send) {
    return render(<h1>The count is: {state}.</h1>, document.body)
  },
  update(state, msg) {
    if (msg) {
      // Set program state to value of message:
      return [msg]
    }
  },
  // Use short form for subscriptions:
  subs(state, send) {
    return startCount
  }
}</code></pre>


              <p>&nbsp;</p>
      </div>
    </section>
  </article>
  <footer>
      <section>
        <svg id='composi-logo-footer' viewBox="0 0 300 300" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
          <title>Composi Logo</title>
          <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
            <g id="Composi-Logo-Solid" fill="rgba(255,255,255,0.5)">
              <path d="M1.77635684e-15,0 L95,0 L95,38 L209,38 L209,0 L300,0 L300,94 L265,93.8571663 L265,209 L300,209 L300,300 L209,300 L209,265 L95,265 L95,300 L1.77635684e-15,300 L1.77635684e-15,209 L40,209 L40,94 L1.77635684e-15,93.8571663 L1.77635684e-15,0 Z M107,107 L107,192 L192,192 L192,107 L107,107 Z" id="Combined-Shape"></path>
            </g>
          </g>
        </svg>
        <h3>Composi is open source (MIT) and available on <a href='https://github.com/composi/core' target='__blank'>Github</a> and <a href="https://www.npmjs.com/package/@composi/core" target='__blank'>NPM</a>.</h3>
      </section>
    </footer>
  <script src="/js/prism.js"></script>


</body>
</html>
